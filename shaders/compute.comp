#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outputImage;
layout(push_constant) uniform PushConstants
{
    uint width;
    uint height;
}
pc;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

bool rayHitSphere(vec3 center, float radius, const Ray r)
{
    vec3 rayToSphereDirection = (center - r.origin);
    float a = dot(r.direction, r.direction);
    float b = dot((-2 * r.direction), rayToSphereDirection);
    float c = dot(rayToSphereDirection, rayToSphereDirection) - pow(radius, 2);

    float discriminant = b * b - 4 * a * c;
    return (discriminant >= 0);
}

vec3 getRayColor(const Ray r)
{
    vec3 unitDirection = normalize(r.direction);
    float a = 0.5 * (unitDirection.y + 1.0);

    vec3 sphereColor = vec3(1, 0, 0);
    vec3 backgroundColor = ((1.0 - a) * vec3(1, 1, 1)) + (a * vec3(0.5, 0.7, 1.0));
    if (rayHitSphere(vec3(0, 0, -1), 0.5, r))
        return sphereColor;
    else
        return backgroundColor;
}

vec3 rayAt(Ray ray, float t)
{
    return ray.origin + (t * ray.direction);
}

void main(void)
{
    float focalLength = 1.0;
    float viewportHeight = 2.0;
    float viewportWidth = viewportHeight * (float(pc.width) / float(pc.height));
    vec3 cameraCenter = vec3(0, 0, 0);

    vec3 viewportU = vec3(viewportWidth, 0, 0);
    vec3 viewportV = vec3(0, -viewportHeight, 0);

    vec3 pixelU = viewportU / pc.width;
    vec3 pixelV = viewportV / pc.height;

    vec3 viewportUpperLeftCorner = cameraCenter - vec3(0, 0, focalLength) - (viewportU / 2) - (viewportV / 2);
    vec3 pixelUpperLeftCorner = viewportUpperLeftCorner + (0.5 * (pixelU + pixelV));

    vec3 pixelCenter = pixelUpperLeftCorner + (float(gl_GlobalInvocationID.x) * pixelU) + (float(gl_GlobalInvocationID.y) * pixelV);
    vec3 rayDirection = pixelCenter - cameraCenter;
    Ray r = { cameraCenter, rayDirection };
    vec3 color = getRayColor(r);

    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}